// use std::{
//     hash::{DefaultHasher, Hash, Hasher},
//     ops::Range,
// };

// #[derive(Debug, Clone)]
// pub struct SparseChars {
//     pub parts: Vec<Range<usize>>,
//     // TODO: Evaluate whether these can be removed
//     pub first: Option<Range<usize>>,
//     pub last: Option<Range<usize>>,
// }
// pub type HashedSparseChars = u64;

// impl SparseChars {
//     pub fn new(parts: Vec<Range<usize>>) -> Self {
//         let mut sp = SparseChars {
//             parts,
//             first: None,
//             last: None,
//         };
//         if sp.parts.len() > 0 {
//             let first = sp.parts.get(0).unwrap();
//             sp.first = Some(first.start..first.end);
//             let last = sp.parts.get(sp.parts.len() - 1).unwrap();
//             sp.last = Some(last.start..last.end);
//         }

//         sp.defrag();

//         sp
//     }
//     /// Generate a hash of the SparseChars content based on the input, used for constructing the Trie
//     pub fn hash(&self, source: &str) -> HashedSparseChars {
//         let mut hasher = DefaultHasher::new();
//         for part in &self.parts {
//             for i in part.clone() {
//                 source.as_bytes()[i].hash(&mut hasher);
//             }
//         }
//         hasher.finish()
//     }
//     /// generated by chat gpt, im not a leetcoder
//     pub fn defrag(&mut self) {
//         if self.parts.is_empty() {
//             return;
//         }

//         let mut i = 0;
//         for j in 1..self.parts.len() {
//             if self.parts[i].end >= self.parts[j].start {
//                 // Merge contiguous or overlapping ranges
//                 self.parts[i].end = self.parts[i].end.max(self.parts[j].end);
//             } else {
//                 // Move the next non-overlapping range forward
//                 i += 1;
//                 self.parts[i] = self.parts[j].clone();
//             }
//         }

//         // Step 3: Truncate to remove extra elements
//         self.parts.truncate(i + 1);
//     }
//     pub fn iter(&self) -> impl Iterator<Item = Range<usize>> {
//         self.parts.iter().map(|range| range.start..range.end)
//     }
//     pub fn first(&self) -> Option<&Range<usize>> {
//         self.first.as_ref()
//     }
//     pub fn last(&self) -> Option<&Range<usize>> {
//         self.last.as_ref()
//     }
// }
