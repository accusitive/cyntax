use std::{
    hash::{DefaultHasher, Hash, Hasher},
    ops::Range,
};

use radix_trie::TrieKey;
use spanned::Spanned;
use strum_macros::EnumString;

pub mod lexer;
pub mod prelexer;
pub mod spanned;

// pub mod tests;
#[derive(Debug)]
pub struct SparseChars {
    pub parts: Vec<Range<usize>>,
    // TODO: Evaluate whether these can be removed
    pub first: Option<Range<usize>>,
    pub last: Option<Range<usize>>,
}
pub type HashedSparseChars = u64;

impl SparseChars {
    pub fn new(parts: Vec<Range<usize>>) -> Self {
        let mut sp = SparseChars {
            parts,
            first: None,
            last: None,
        };
        if sp.parts.len() > 0 {
            let first = sp.parts.get(0).unwrap();
            sp.first = Some(first.start..first.end);
            let last = sp.parts.get(sp.parts.len() - 1).unwrap();
            sp.last = Some(last.start..last.end);
        }

        sp.defrag();

        sp
    }
    /// Generate a hash of the SparseChars content based on the input, used for constructing the Trie
    pub fn hashed(&self, source: &str) -> HashedSparseChars {
        let mut hasher = DefaultHasher::new();
        for part in &self.parts {
            for i in part.clone() {
                source.as_bytes()[i].hash(&mut hasher);
            }
        }
        hasher.finish()
    }
    /// generated by chat gpt, im not a leetcoder
    pub fn defrag(&mut self) {
        if self.parts.is_empty() {
            return;
        }

        let mut i = 0;
        for j in 1..self.parts.len() {
            if self.parts[i].end >= self.parts[j].start {
                // Merge contiguous or overlapping ranges
                self.parts[i].end = self.parts[i].end.max(self.parts[j].end);
            } else {
                // Move the next non-overlapping range forward
                i += 1;
                self.parts[i] = self.parts[j].clone();
            }
        }

        // Step 3: Truncate to remove extra elements
        self.parts.truncate(i + 1);
    }
    pub fn iter(&self) -> impl Iterator<Item = Range<usize>> {
        self.parts.iter().map(|range| range.start..range.end)
    }
    pub fn first(&self) -> Option<&Range<usize>> {
        self.first.as_ref()
    }
    pub fn last(&self) -> Option<&Range<usize>> {
        self.last.as_ref()
    }
}
// #[test]
// pub fn test_simple_sparse_char() {
//     let ranges = vec![0..1, 1..2, 2..3, 5..6, 6..7];
//     let mut nsp = NewSparseChars {
//         parts: ranges
//     };
//     nsp.defrag();;
//     panic!("{:#?}", nsp);
// }
// pub type SparseChars = Vec<Range<usize>>;
#[derive(Debug)]
pub enum Token {
    Identifier(SparseChars),
    StringLiteral(Vec<Range<usize>>),
    PPNumber(SparseChars),

    // Directive(Directive),
    ControlLine(Vec<Spanned<Token>>),

    Whitespace(Whitespace),
    Punctuator(Punctuator),

    Delimited(char, char, Spanned<Vec<Spanned<Token>>>),
}
#[derive(Debug)]
pub enum Directive {
    DefineObject(Spanned<SparseChars>, Vec<Spanned<Token>>),
    DefineFunction(
        Spanned<SparseChars>,
        Spanned<Vec<Spanned<Token>>>,
        Vec<Spanned<Token>>,
    ),
    Undefine(Spanned<SparseChars>),
}
#[derive(Debug, PartialEq)]
pub enum Whitespace {
    /// ` `
    Space,
    /// \n
    Newline,
    /// \t
    Tab,
}
#[derive(Debug, PartialEq)]
pub enum Punctuator {
    // Brackets and Parentheses
    LeftBracket,  // [
    RightBracket, // ]
    LeftParen,    // (
    RightParen,   // )
    LeftBrace,    // {
    RightBrace,   // }
    Dot,          // .
    Arrow,        // ->

    // Unary and Increment/Decrement Operators
    Increment,   // ++
    Decrement,   // --
    Ampersand,   // &
    Asterisk,    // *
    Plus,        // +
    Minus,       // -
    Tilde,       // ~
    Exclamation, // !

    // Arithmetic and Bitwise Operators
    Slash,        // /
    Percent,      // %
    ShiftLeft,    // <<
    ShiftRight,   // >>
    LessThan,     // <
    GreaterThan,  // >
    LessEqual,    // <=
    GreaterEqual, // >=
    Equal,        // ==
    NotEqual,     // !=
    Caret,        // ^
    Pipe,         // |
    And,          // &&
    Or,           // ||

    // Ternary and Colon Operators
    Question,  // ?
    Colon,     // :
    Semicolon, // ;
    Ellipsis,  // ...

    // Assignment Operators
    Assign,    // =
    MulAssign, // *=
    DivAssign, // /=
    ModAssign, // %=
    AddAssign, // +=
    SubAssign, // -=
    ShlAssign, // <<=
    ShrAssign, // >>=
    AndAssign, // &=
    XorAssign, // ^=
    OrAssign,  // |=

    // Miscellaneous
    Comma,     // ,
    Directive, // #, but only if its the first non-whitespace character of the line
    Hash,      // #
    HashHash,  // ##

    // Digraphs (Alternative Tokens)
    LessColon,                // <:
    ColonGreater,             // :>
    LessPercent,              // <%
    PercentGreater,           // %>
    PercentColon,             // %:
    PercentColonPercentColon, // %:%:
}

#[derive(Debug, Clone, PartialEq, Eq, EnumString)]
#[strum(serialize_all = "lowercase")]
pub enum Keyword {
    Auto,
    Break,
    Case,
    Char,
    Const,
    Continue,
    Default,
    Do,
    Double,
    Else,
    Enum,
    Extern,
    Float,
    For,
    Goto,
    If,
    Inline,
    Int,
    Long,
    Register,
    Restrict,
    Return,
    Short,
    Signed,
    Sizeof,
    Static,
    Struct,
    Switch,
    Typedef,
    Union,
    Unsigned,
    Void,
    Volatile,
    While,
    #[strum(serialize = "_Bool")]
    Bool,
    #[strum(serialize = "_Complex")]
    Complex,
    #[strum(serialize = "_Imaginary")]
    Imaginary,
}

impl Punctuator {
    pub fn to_string(&self) -> String {
        match self {
            Punctuator::LeftBracket => "[".to_string(),
            Punctuator::RightBracket => "".to_string(),
            Punctuator::LeftParen => "(".to_string(),
            Punctuator::RightParen => ")".to_string(),
            Punctuator::LeftBrace => "{".to_string(),
            Punctuator::RightBrace => "}".to_string(),
            Punctuator::Dot => ".".to_string(),
            Punctuator::Arrow => "->".to_string(),
            Punctuator::Increment => "++".to_string(),
            Punctuator::Decrement => "--".to_string(),
            Punctuator::Ampersand => "&".to_string(),
            Punctuator::Asterisk => "*".to_string(),
            Punctuator::Plus => "+".to_string(),
            Punctuator::Minus => "-".to_string(),
            Punctuator::Tilde => "~".to_string(),
            Punctuator::Exclamation => "!".to_string(),
            Punctuator::Slash => "/".to_string(),
            Punctuator::Percent => "%".to_string(),
            Punctuator::ShiftLeft => "<<".to_string(),
            Punctuator::ShiftRight => ">>".to_string(),
            Punctuator::LessThan => "<".to_string(),
            Punctuator::GreaterThan => ">".to_string(),
            Punctuator::LessEqual => "<=".to_string(),
            Punctuator::GreaterEqual => "".to_string(),
            Punctuator::Equal => "==".to_string(),
            Punctuator::NotEqual => "!=".to_string(),
            Punctuator::Caret => "^".to_string(),
            Punctuator::Pipe => "|".to_string(),
            Punctuator::And => "&&".to_string(),
            Punctuator::Or => "||".to_string(),
            Punctuator::Question => "?".to_string(),
            Punctuator::Colon => ":".to_string(),
            Punctuator::Semicolon => ";".to_string(),
            Punctuator::Ellipsis => "...".to_string(),
            Punctuator::Assign => "=".to_string(),
            Punctuator::MulAssign => "*=".to_string(),
            Punctuator::DivAssign => "/=".to_string(),
            Punctuator::ModAssign => "%=".to_string(),
            Punctuator::AddAssign => "+=".to_string(),
            Punctuator::SubAssign => "-=".to_string(),
            Punctuator::ShlAssign => "<<=".to_string(),
            Punctuator::ShrAssign => ">>=".to_string(),
            Punctuator::AndAssign => "&=".to_string(),
            Punctuator::XorAssign => "^=".to_string(),
            Punctuator::OrAssign => "|=".to_string(),
            Punctuator::Comma => ",".to_string(),
            // Use alternate character `♯` instead of `#` for debug printing, to make it clear that its a Directive not a Hash
            Punctuator::Directive => "♯".to_string(),
            Punctuator::Hash => "#".to_string(),
            Punctuator::HashHash => "##".to_string(),
            Punctuator::LessColon => "<:".to_string(),
            Punctuator::ColonGreater => "".to_string(),
            Punctuator::LessPercent => "<%".to_string(),
            Punctuator::PercentGreater => "%>".to_string(),
            Punctuator::PercentColon => "%:".to_string(),
            Punctuator::PercentColonPercentColon => "%:%:".to_string(),
        }
    }
    pub fn is_punctuation(c: char) -> bool {
        Punctuator::from_char(c).is_some()
    }
    pub fn from_char(c: char) -> Option<Punctuator> {
        match c {
            '[' => Some(Punctuator::LeftBracket),
            ']' => Some(Punctuator::RightBracket),
            '(' => Some(Punctuator::LeftParen),
            ')' => Some(Punctuator::RightParen),
            '{' => Some(Punctuator::LeftBrace),
            '}' => Some(Punctuator::RightBrace),
            '.' => Some(Punctuator::Dot),
            '&' => Some(Punctuator::Ampersand),
            '*' => Some(Punctuator::Asterisk),
            '+' => Some(Punctuator::Plus),
            '-' => Some(Punctuator::Minus),
            '~' => Some(Punctuator::Tilde),
            '!' => Some(Punctuator::Exclamation),
            '/' => Some(Punctuator::Slash),
            '%' => Some(Punctuator::Percent),
            '<' => Some(Punctuator::LessThan),
            '>' => Some(Punctuator::GreaterThan),
            '^' => Some(Punctuator::Caret),
            '|' => Some(Punctuator::Pipe),
            '?' => Some(Punctuator::Question),
            ':' => Some(Punctuator::Colon),
            ';' => Some(Punctuator::Semicolon),
            '=' => Some(Punctuator::Assign),
            ',' => Some(Punctuator::Comma),
            '#' => Some(Punctuator::Hash),
            _ => None,
        }
    }
}
